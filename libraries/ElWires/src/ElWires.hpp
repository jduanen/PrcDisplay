/*
* Library that drives EL wires with different patterns and speeds
*
* N.B. The patterns are generated by tools/seqgen.c
*/

#define FUDGE_FACTOR		1


ElWires::ElWires() {
	_create(false);
};

// FIXME this is a sleazy hack to get around startup problems with XIAO ESP32
ElWires::ElWires(bool delayedStart) {
	_create(delayedStart);
};

void ElWires::_create(bool delayedStart) {
	_numElWires = NUM_EL_WIRES;
	_numSequences = NUM_SEQUENCES;

    _prcd.pinMode(P0, OUTPUT, HIGH);
    _prcd.pinMode(P1, OUTPUT, HIGH);
    _prcd.pinMode(P2, OUTPUT, HIGH);
    _prcd.pinMode(P3, OUTPUT, HIGH);
    _prcd.pinMode(P4, OUTPUT, HIGH);
    _prcd.pinMode(P5, OUTPUT, HIGH);
    _prcd.pinMode(P6, OUTPUT, HIGH);
    _prcd.pinMode(P7, OUTPUT, HIGH);

    if (!delayedStart) {
	    _prcd.begin();
	}

    clear();

    // use floating input as source of randomness
    randomSeed(analogRead(UNUSED_ANALOG));
};

void ElWires::start() {
	_prcd.begin();
}

unsigned short ElWires::numSequences() {
	return _numSequences;
};

bool ElWires::randomSequence() {
	return _randomSequence;
};

void ElWires::enableRandomSequence(bool enable) {
	_randomSequence = enable;
    _nextRunTime = millis() + FUDGE_FACTOR;
};

unsigned short  ElWires::sequenceNumber() {
	return _sequenceNumber;
};

uint ElWires::sequenceDelay() {
	return _sequenceDelay;
};

void ElWires::setSequence(unsigned short number, uint32_t delay) {
	_sequenceNumber = number;
	_sequenceDelay = delay;
	_seqIndx = 0;
    _nextRunTime = millis() + FUDGE_FACTOR;
};

void ElWires::clear() {
    for (int wire = 0; (wire < _numElWires); wire++) {
    	_prcd.digitalWrite(wire, HIGH);
    }
	_seqIndx = 0;
};

void ElWires::writeAll(byte values) {
	PCF8574::DigitalInput digitalInput;

    digitalInput.p7 = bitRead(values, 7);
    digitalInput.p6 = bitRead(values, 6);
    digitalInput.p5 = bitRead(values, 5);
    digitalInput.p4 = bitRead(values, 4);
    digitalInput.p3 = bitRead(values, 3);
    digitalInput.p2 = bitRead(values, 2);
    digitalInput.p1 = bitRead(values, 1);
    digitalInput.p0 = bitRead(values, 0);

    _prcd.digitalWriteAll(digitalInput);
};

#define EL_FUDGE_FACTOR        10  // let things be up to 10msec late without complaining

unsigned long ElWires::run() {
	int wireEnables;
    unsigned long now = millis();

    if (now > (_nextRunTime + EL_FUDGE_FACTOR)) {
        Serial.println("WARNING EL: " + String(now - _nextRunTime) + " msec late");
    } else {
        if (_nextRunTime > now) {
            return ((_nextRunTime - now) - 1);  // deduct a msec to account for overheads
        }
    }
	if (_randomSequence == true) {
		wireEnables = random(0, 255);
	} else {
		if (_seqIndx >= sequenceDefinitions[_sequenceNumber].length) {
			_seqIndx = 0;
		}
		wireEnables = patterns[sequenceDefinitions[_sequenceNumber].offset + _seqIndx++];
	}
	if (false) {
		Serial.println("EL: 0x" + String(wireEnables, HEX));
	}
	writeAll(wireEnables);

	_nextRunTime = millis() + _sequenceDelay;
    return 0L;
};
