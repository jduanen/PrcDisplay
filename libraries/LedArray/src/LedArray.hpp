/*
* Library that scrolls messages on a small (<32 columns) array of LEDs
*
* N.B. Fonts are built-in and generated by fontgen.c
*/

template<uint8_t Size>
LedArray<Size>::LedArray(uint8_t dataPin, uint8_t srClkPin, uint8_t rClkPin, uint8_t oePin, uint8_t numRows, uint8_t numCols, int scrollSpeed) {
    _stdWaitCycles = scrollSpeed;
    _waitCycles = _stdWaitCycles;
    _numRows = numRows;
    _numCols = numCols;
    _frameBufferPtr = new uint32_t[numRows];
    _srPtr = new ShiftRegister74HC595<Size>(dataPin, srClkPin, rClkPin);
    _oePin = oePin;
    pinMode(_oePin, OUTPUT);
    digitalWrite(_oePin, LOW);  // start off enabled
}

template<uint8_t Size>
void LedArray<Size>::clear() {
    for (int i = 0; i < _numRows; i++) {
        _frameBufferPtr[i] = 0;
    }
}

template<uint8_t Size>
void LedArray<Size>::fill(uint32_t val) {
    for (int i = 0; i < _numRows; i++) {
        _frameBufferPtr[i] = val;
    }
}

template<uint8_t Size>
void LedArray<Size>::run() {
    if ((_loopCount % _waitCycles) == 0) {
        _waitCycles = _stdWaitCycles;
        scrollMessage();
    }
    if (_blinkRate > 0) {
//        enableDisplay((_loopCount >> _blinkRate) & 1);
    }
    scanDisplay();
    _loopCount++;
}

//// FIXME DRY this all up

template<uint8_t Size>
void LedArray<Size>::message(const String& str, char font) {
    _fontNums = "";
    assert((font >= '0') && (font < ('0' + NUM_FONTS))); // Invalid font number selection
    for (int i = 0; (i < str.length()); i++) {
        _fontNums.concat(font);
    }
    _msg = str;
}

template<uint8_t Size>
void LedArray<Size>::message(char str[], char font) {
    _fontNums = "";
    assert((font >= '0') && (font < ('0' + NUM_FONTS))); // Invalid font number selection
    for (int i = 0; (i < strlen(str)); i++) {
        _fontNums.concat(font);
    }
    _msg = String(str);
}

template<uint8_t Size>
void LedArray<Size>::appendMessage(const String& str, char font) {
    assert((font >= '0') && (font < ('0' + NUM_FONTS))); // Invalid font number selection
    for (int i = 0; (i < str.length()); i++) {
        _fontNums.concat(font);
    }
    _msg.concat(str);
}

template<uint8_t Size>
void LedArray<Size>::appendMessage(char str[], char font) {
    assert((font >= '0') && (font < ('0' + NUM_FONTS))); // Invalid font number selection
    for (int i = 0; (i < strlen(str)); i++) {
        _fontNums.concat(font);
    }
    _msg.concat(String(str));
}

/*
template<uint8_t Size>
void LedArray<Size>::writeToFB(char *strPtr) {
  for (int j = 0; j < strlen(strPtr); j++) {
    char c = strPtr[j];
    int columnMask = ((1 << fonts[_fontNumber][c].columns) - 1);
    for (int i = 0; i < _numRows; i++) {
      _frameBufferPtr[i] = (_frameBufferPtr[i] << (fonts[_fontNumber][c].columns + 1)) | (fonts[_fontNumber][c].code[i] & columnMask);
    }
  }
}
*/

template<uint8_t Size>
void LedArray<Size>::scrollMessage() {
    int fontNumber;
    char c = _msg.charAt(_curChar);
    if (c != 0) {
        fontNumber = _fontNums.charAt(_curChar) - '0';
        for (int i = 0; i < _numRows; i++) {
            _frameBufferPtr[i] = (_frameBufferPtr[i] << 1) | ((fonts[fontNumber][c].code[i] >> ((fonts[fontNumber][c].columns - 1) - _curCol)) & 0x01);
        }
    }
    _curCol++;
    if (_curCol > fonts[fontNumber][c].columns) {
        _curCol = 0;
        _curChar++;
    }
    if (_curChar >= _msg.length()) {
        _curChar = 0;
        _waitCycles = LONG_WAIT;
    }
}

template<uint8_t Size>
void LedArray<Size>::scanDisplay() {
    int rowSelect;
    // layout: [nc[3:0], rows[6:3]], [rows[2:0], cols[20:16]], [cols[15:8]], [cols[7:0]]
    uint8_t srValues[_numRows][Size];
    uint8_t clearLine[Size] = {0xFF, 0xFF, 0x1F, 0x00};

    // scan all of the FB's lines out to the display
    for (int i = 0; i < _numRows; i++) {
        rowSelect = (1 << i);
        srValues[i][0] = ~(_frameBufferPtr[i] & 0xFF);
        srValues[i][1] = ~((_frameBufferPtr[i] >> 8) & 0xFF);
        srValues[i][2] = ((rowSelect & 0x07) << 5) | (~(_frameBufferPtr[i] >> 16) & 0x1F);
        srValues[i][3] = ((rowSelect >> 3) & 0x0F);
        _srPtr->setAll(srValues[i]);
    }

    // clear the last line
    _srPtr->setAll(clearLine);
}

template<uint8_t Size>
void LedArray<Size>::clearDisplay() {
   uint8_t srValues[Size] = {0,};

    for (int i = 0; i < _numRows; i++) {
        _srPtr->setAll(srValues);
    }
}

template<uint8_t Size>
void LedArray<Size>::enableDisplay(bool enable) {
    digitalWrite(_oePin, (enable ? LOW : HIGH));
    _displayEnabled = enable;
}

template<uint8_t Size>
void LedArray<Size>::blinkDisplay(byte rate) {
    _blinkRate = rate;
}
